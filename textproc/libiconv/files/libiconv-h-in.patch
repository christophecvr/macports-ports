--- include/iconv.h.build.in.orig	2022-05-15 14:59:00.000000000 +0200
+++ include/iconv.h.build.in	2024-12-01 09:29:52.000000000 +0100
@@ -75,9 +75,10 @@
 /* Allocates descriptor for code conversion from encoding ‘fromcode’ to
    encoding ‘tocode’. */
 #ifndef LIBICONV_PLUG
-#define iconv_open libiconv_open
+//#define iconv_open libiconv_open
 #endif
 extern LIBICONV_DLL_EXPORTED iconv_t iconv_open (const char* tocode, const char* fromcode);
+extern LIBICONV_DLL_EXPORTED iconv_t libiconv_open (const char* tocode, const char* fromcode);
 
 /* Converts, using conversion descriptor ‘cd’, at most ‘*inbytesleft’ bytes
    starting at ‘*inbuf’, writing at most ‘*outbytesleft’ bytes starting at
@@ -85,16 +86,17 @@
    Decrements ‘*inbytesleft’ and increments ‘*inbuf’ by the same amount.
    Decrements ‘*outbytesleft’ and increments ‘*outbuf’ by the same amount. */
 #ifndef LIBICONV_PLUG
-#define iconv libiconv
+//#define iconv libiconv
 #endif
 extern LIBICONV_DLL_EXPORTED size_t iconv (iconv_t cd, @ICONV_CONST@ char* * inbuf, size_t *inbytesleft, char* * outbuf, size_t *outbytesleft);
+extern LIBICONV_DLL_EXPORTED size_t libiconv (iconv_t cd, @ICONV_CONST@ char* * inbuf, size_t *inbytesleft, char* * outbuf, size_t *outbytesleft);
 
 /* Frees resources allocated for conversion descriptor ‘cd’. */
 #ifndef LIBICONV_PLUG
-#define iconv_close libiconv_close
+//#define iconv_close libiconv_close
 #endif
 extern LIBICONV_DLL_EXPORTED int iconv_close (iconv_t cd);
-
+extern LIBICONV_DLL_EXPORTED int libiconv_close (iconv_t cd);
 
 #ifdef __cplusplus
 }
@@ -139,8 +141,9 @@
                             iconv_allocation_t* resultp);
 
 /* Control of attributes. */
-#define iconvctl libiconvctl
+//#define iconvctl libiconvctl
 extern LIBICONV_DLL_EXPORTED int iconvctl (iconv_t cd, int request, void* argument);
+extern LIBICONV_DLL_EXPORTED int libiconvctl (iconv_t cd, int request, void* argument);
 
 /* Hook performed after every successful conversion of a Unicode character. */
 typedef void (*iconv_unicode_char_hook) (unsigned int uc, void* data);
@@ -219,12 +222,15 @@
 #define ICONV_SET_FALLBACKS       6  /* const struct iconv_fallbacks *argument */
 
 /* Listing of locale independent encodings. */
-#define iconvlist libiconvlist
+//#define iconvlist libiconvlist
 extern LIBICONV_DLL_EXPORTED void iconvlist (int (*do_one) (unsigned int namescount,
                                       const char * const * names,
                                       void* data),
                        void* data);
-
+extern LIBICONV_DLL_EXPORTED void libiconvlist (int (*do_one) (unsigned int namescount,
+                                      const char * const * names,
+                                      void* data),
+                       void* data);
 /* Canonicalize an encoding name.
    The result is either a canonical encoding name, or name itself. */
 extern LIBICONV_DLL_EXPORTED const char * iconv_canonicalize (const char * name);
--- lib/iconv.c.orig	2022-01-23 23:36:33.000000000 +0100
+++ lib/iconv.c	2024-12-01 09:25:18.000000000 +0100
@@ -259,6 +259,34 @@
   return (iconv_t)(-1);
 }
 
+iconv_t libiconv_open (const char* tocode, const char* fromcode)
+{
+  struct conv_struct * cd;
+  unsigned int from_index;
+  int from_wchar;
+  unsigned int to_index;
+  int to_wchar;
+  int transliterate;
+  int discard_ilseq;
+
+#include "iconv_open1.h"
+
+  cd = (struct conv_struct *) malloc(from_wchar != to_wchar
+                                     ? sizeof(struct wchar_conv_struct)
+                                     : sizeof(struct conv_struct));
+  if (cd == NULL) {
+    errno = ENOMEM;
+    return (iconv_t)(-1);
+  }
+
+#include "iconv_open2.h"
+
+  return (iconv_t)cd;
+invalid:
+  errno = EINVAL;
+  return (iconv_t)(-1);
+}
+
 size_t iconv (iconv_t icd,
               ICONV_CONST char* * inbuf, size_t *inbytesleft,
               char* * outbuf, size_t *outbytesleft)
@@ -272,6 +300,19 @@
                                    outbuf,outbytesleft);
 }
 
+size_t libiconv (iconv_t icd,
+              ICONV_CONST char* * inbuf, size_t *inbytesleft,
+              char* * outbuf, size_t *outbytesleft)
+{
+  conv_t cd = (conv_t) icd;
+  if (inbuf == NULL || *inbuf == NULL)
+    return cd->lfuncs.loop_reset(icd,outbuf,outbytesleft);
+  else
+    return cd->lfuncs.loop_convert(icd,
+                                   (const char* *)inbuf,inbytesleft,
+                                   outbuf,outbytesleft);
+}
+
 int iconv_close (iconv_t icd)
 {
   conv_t cd = (conv_t) icd;
@@ -279,6 +320,13 @@
   return 0;
 }
 
+int libiconv_close (iconv_t icd)
+{
+  conv_t cd = (conv_t) icd;
+  free(cd);
+  return 0;
+}
+
 #ifndef LIBICONV_PLUG
 
 /*
@@ -364,6 +412,55 @@
   }
 }
 
+int libiconvctl (iconv_t icd, int request, void* argument)
+{
+  conv_t cd = (conv_t) icd;
+  switch (request) {
+    case ICONV_TRIVIALP:
+      *(int *)argument =
+        ((cd->lfuncs.loop_convert == unicode_loop_convert
+          && cd->iindex == cd->oindex)
+         || cd->lfuncs.loop_convert == wchar_id_loop_convert
+         ? 1 : 0);
+      return 0;
+    case ICONV_GET_TRANSLITERATE:
+      *(int *)argument = cd->transliterate;
+      return 0;
+    case ICONV_SET_TRANSLITERATE:
+      cd->transliterate = (*(const int *)argument ? 1 : 0);
+      return 0;
+    case ICONV_GET_DISCARD_ILSEQ:
+      *(int *)argument = cd->discard_ilseq;
+      return 0;
+    case ICONV_SET_DISCARD_ILSEQ:
+      cd->discard_ilseq = (*(const int *)argument ? 1 : 0);
+      return 0;
+    case ICONV_SET_HOOKS:
+      if (argument != NULL) {
+        cd->hooks = *(const struct iconv_hooks *)argument;
+      } else {
+        cd->hooks.uc_hook = NULL;
+        cd->hooks.wc_hook = NULL;
+        cd->hooks.data = NULL;
+      }
+      return 0;
+    case ICONV_SET_FALLBACKS:
+      if (argument != NULL) {
+        cd->fallbacks = *(const struct iconv_fallbacks *)argument;
+      } else {
+        cd->fallbacks.mb_to_uc_fallback = NULL;
+        cd->fallbacks.uc_to_mb_fallback = NULL;
+        cd->fallbacks.mb_to_wc_fallback = NULL;
+        cd->fallbacks.wc_to_mb_fallback = NULL;
+        cd->fallbacks.data = NULL;
+      }
+      return 0;
+    default:
+      errno = EINVAL;
+      return -1;
+  }
+}
+
 /* An alias after its name has been converted from 'int' to 'const char*'. */
 struct nalias { const char* name; unsigned int encoding_index; };
 
@@ -451,6 +548,70 @@
 #undef aliascount1
 }
 
+void libiconvlist (int (*do_one) (unsigned int namescount,
+                               const char * const * names,
+                               void* data),
+                void* data)
+{
+#define aliascount1  sizeof(aliases)/sizeof(aliases[0])
+#ifndef aliases2_lookup
+#define aliascount2  sizeof(sysdep_aliases)/sizeof(sysdep_aliases[0])
+#else
+#define aliascount2  0
+#endif
+#define aliascount  (aliascount1+aliascount2)
+  struct nalias aliasbuf[aliascount];
+  const char * namesbuf[aliascount];
+  size_t num_aliases;
+  {
+    /* Put all existing aliases into a buffer. */
+    size_t i;
+    size_t j;
+    j = 0;
+    for (i = 0; i < aliascount1; i++) {
+      const struct alias * p = &aliases[i];
+      if (p->name >= 0
+          && p->encoding_index != ei_local_char
+          && p->encoding_index != ei_local_wchar_t) {
+        aliasbuf[j].name = stringpool + p->name;
+        aliasbuf[j].encoding_index = p->encoding_index;
+        j++;
+      }
+    }
+#ifndef aliases2_lookup
+    for (i = 0; i < aliascount2; i++) {
+      aliasbuf[j].name = stringpool2 + sysdep_aliases[i].name;
+      aliasbuf[j].encoding_index = sysdep_aliases[i].encoding_index;
+      j++;
+    }
+#endif
+    num_aliases = j;
+  }
+  /* Sort by encoding_index. */
+  if (num_aliases > 1)
+    qsort(aliasbuf, num_aliases, sizeof(struct nalias), compare_by_index);
+  {
+    /* Process all aliases with the same encoding_index together. */
+    size_t j;
+    j = 0;
+    while (j < num_aliases) {
+      unsigned int ei = aliasbuf[j].encoding_index;
+      size_t i = 0;
+      do
+        namesbuf[i++] = aliasbuf[j++].name;
+      while (j < num_aliases && aliasbuf[j].encoding_index == ei);
+      if (i > 1)
+        qsort(namesbuf, i, sizeof(const char *), compare_by_name);
+      /* Call the callback. */
+      if (do_one(i,namesbuf,data))
+        break;
+    }
+  }
+#undef aliascount
+#undef aliascount2
+#undef aliascount1
+}
+
 /*
  * Table of canonical names of encodings.
  * Instead of strings, it contains offsets into stringpool and stringpool2.
